
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>openbci_stream.daemons.stream_eeg &#8212; OpenBCI-Stream  documentation</title>
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/custom.css" />
    <script id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <link rel="shortcut icon" href="../../../_static/favico.ico"/>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
   
  <link rel="stylesheet" href="../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for openbci_stream.daemons.stream_eeg</h1><div class="highlight"><pre>
<span></span>&quot;&quot;&quot;
=============
Binary to EEG
=============

A transformer for Kafka that reads binary data and stream EEG data.

Binary -&gt; Kafka-Transformer -&gt; EEG

For examples and descriptions refers to documentation:
`Data storage handler &lt;../A1-raw_cleaning.ipynb&gt;`_
&quot;&quot;&quot;

import sys
import pickle
import struct
from functools import cached_property
import numpy as np
from multiprocessing import Pool
from datetime import datetime
import rawutil
import logging

from kafka import KafkaConsumer, KafkaProducer
from typing import TypeVar, List, Dict, Tuple, Any

from openbci_stream.utils import autokill_process
autokill_process(name=&#39;binary_2_eeg&#39;)

DEBUG = (&#39;--debug&#39; in sys.argv)

KafkaStream = TypeVar(&#39;kafka-stream&#39;)

########################################################################


<div class="viewcode-block" id="BinaryToEEG"><a class="viewcode-back" href="../../openbci_stream.daemons.stream_eeg.html#openbci_stream.daemons.stream_eeg.BinaryToEEG">[docs]</a>class BinaryToEEG:
    &quot;&quot;&quot;Kafka transformer with parallel implementation for processing binary raw
    data into EEG microvolts. This script requires the Kafka daemon running and
    enables an `auto-kill process &lt;openbci_stream.utils.pid_admin.rst#module-openbci_stream.utils.pid_admin&gt;`_
    &quot;&quot;&quot;

    BIN_HEADER = 0xa0
    LAST_AUX_SHAPE = 0

    # ----------------------------------------------------------------------
    def __init__(self):
        &quot;&quot;&quot;&quot;&quot;&quot;

        self.consumer_binary = KafkaConsumer(bootstrap_servers=[&#39;localhost:9092&#39;],
                                             value_deserializer=pickle.loads,
                                             auto_offset_reset=&#39;latest&#39;,
                                             )
        self.consumer_binary.subscribe([&#39;binary&#39;])

        self.producer_eeg = KafkaProducer(bootstrap_servers=[&#39;localhost:9092&#39;],
                                          compression_type=&#39;gzip&#39;,
                                          value_serializer=pickle.dumps,
                                          )

        # self.buffer = Queue(maxsize=33)

        self._last_marker = 0
        self.counter = 0

        self.remnant = b&#39;&#39;
        self.offset = None, None
        # self._last_aux_shape = 0

    # ----------------------------------------------------------------------
    @cached_property
    def scale_factor_eeg(self) -&gt; float:
        &quot;&quot;&quot;Vector with the correct factors for scale eeg data samples.&quot;&quot;&quot;
        gain = 24
        # vref = 4.5  # for V
        vref = 4500000  # for uV

        return vref / (gain * ((2 ** 23) - 1))

    # ----------------------------------------------------------------------
<div class="viewcode-block" id="BinaryToEEG.consume"><a class="viewcode-back" href="../../openbci_stream.daemons.stream_eeg.html#openbci_stream.daemons.stream_eeg.BinaryToEEG.consume">[docs]</a>    def consume(self) -&gt; None:
        &quot;&quot;&quot;Infinite loop for read Kafka stream.&quot;&quot;&quot;
        while True:
            for record in self.consumer_binary:
                if DEBUG:
                    logging.info(f&quot;processing {len(record.value[&#39;data&#39;])}&quot;)
                self.process(record)</div>

    # ----------------------------------------------------------------------
<div class="viewcode-block" id="BinaryToEEG.process"><a class="viewcode-back" href="../../openbci_stream.daemons.stream_eeg.html#openbci_stream.daemons.stream_eeg.BinaryToEEG.process">[docs]</a>    def process(self, record: KafkaStream) -&gt; None:
        &quot;&quot;&quot;Prepare the binary package for a successful unpack and stream.

        Parameters
        ----------
        record
            Kafka stream with binary data.
        &quot;&quot;&quot;
        buffer = record.value
        context = buffer[&#39;context&#39;]
        context[&#39;timestamp.binary.consume&#39;] = datetime.now().timestamp()

        # Deserialice data
        data, self.remnant = self.align_data(self.remnant + buffer[&#39;data&#39;])
        if not data.shape[0]:
            if DEBUG:
                logging.warning(&#39;No data after alignement&#39;)
            return
        eeg_data, aux = self.deserialize(data, context)

        # Stream
        context[&#39;samples&#39;] = eeg_data.shape[1]
        context[&#39;timestamp.eeg&#39;] = datetime.now().timestamp()

        self.stream([eeg_data, aux], context)</div>

    # ----------------------------------------------------------------------

<div class="viewcode-block" id="BinaryToEEG.align_data"><a class="viewcode-back" href="../../openbci_stream.daemons.stream_eeg.html#openbci_stream.daemons.stream_eeg.BinaryToEEG.align_data">[docs]</a>    def align_data(self, binary: bytes) -&gt; Tuple[np.ndarray, bytes]:
        &quot;&quot;&quot;Align data following the headers and footers.

        Parameters
        ----------
        binary
            Data raw from OpenBCI board.

        Returns
        -------
        data_aligned
            Numpy array of shape (`33, LENGTH`) with headers and footer aligned.
        remnant
            This bytes could be used for complete next binary input.
        &quot;&quot;&quot;

        data = np.array(list(binary))

        # Search for the the first index with a `BIN_HEADER`
        start = [np.median(np.roll(data, -i, axis=0)[::33])
                 == self.BIN_HEADER for i in range(33)].index(True)

        if (start == 0) and (data.shape[0] % 33 == 0):
            data_aligned = data
            remnant = b&#39;&#39;
        else:
            # Fix the offset to complete 33 bytes divisible array
            end = (data.shape[0] - start) % 33
            data_aligned = data[start:-end]
            remnant = binary[-end:]

        data_aligned = data_aligned.reshape(-1, 33)

        return data_aligned, remnant</div>

    # ----------------------------------------------------------------------
<div class="viewcode-block" id="BinaryToEEG.deserialize"><a class="viewcode-back" href="../../openbci_stream.daemons.stream_eeg.html#openbci_stream.daemons.stream_eeg.BinaryToEEG.deserialize">[docs]</a>    def deserialize(self, data: np.ndarray, context: Dict[str, Any]) -&gt; None:
        &quot;&quot;&quot;From signed 24-bits integer to signed 32-bits integer.

        Parameters
        ----------
        data
            Numpy array of shape (`33, LENGTH`)
        context
            Information from the acquisition side useful for deserializing and
            that will be packaged back in the stream.
        &quot;&quot;&quot;

        # EGG
        eeg_data = data[:, 2:26]
        eeg_data = getattr(self, f&#39;deserialize_eeg_{context[&quot;connection&quot;]}&#39;)(
            eeg_data, data[:, 1], context)

        # Auxiliar
        stop_byte = int((np.median(data[:, -1])))
        aux = self.deserialize_aux(stop_byte, data[:, 26:32], context)
        self.LAST_AUX_SHAPE = aux.shape

        # Stream
        channels = list(context[&#39;montage&#39;].keys())

        return eeg_data.T[channels], aux.T</div>
        # self.stream([eeg_data.T[channels], aux.T], eeg_data.shape[0], context)

    # ----------------------------------------------------------------------
<div class="viewcode-block" id="BinaryToEEG.deserialize_eeg_wifi"><a class="viewcode-back" href="../../openbci_stream.daemons.stream_eeg.html#openbci_stream.daemons.stream_eeg.BinaryToEEG.deserialize_eeg_wifi">[docs]</a>    def deserialize_eeg_wifi(self, eeg: np.ndarray, ids: np.ndarray, context: Dict[str, Any]) -&gt; np.ndarray:
        &quot;&quot;&quot;From signed 24-bits integer to signed 32-bits integer by channels.

        The `Cyton data format &lt;https://docs.openbci.com/docs/02Cyton/CytonDataFormat&gt;`_
        says that only can send packages of 33 bits, when a Daisy board is
        attached these same packages will be sent at double speed in favor to
        keep the desired sample rate for 16 channels.

        Parameters
        ----------
        eeg
            Numpy array in signed 24-bits integer (`8, LENGTH`)
        ids
            List of IDs for eeg data.
        context
            Information from the acquisition side useful for deserializing and
            that will be packaged back in the stream.

        Returns
        -------
        eeg_data
            EEG data in microvolts, signed 32-bits integer, (`CHANNELS, LENGTH`),
            if there is a Daisy board `CHANNELS` is 16, otherwise is 8.
        &quot;&quot;&quot;

        # eeg_data = np.array([[rawutil.unpack(&#39;&gt;u&#39;, bytes(ch))[0] for ch in row.reshape(-1, 3).tolist()] for row in eeg])
        eeg_data = np.array([rawutil.unpack(&#39;&gt;u&#39;, bytes(ch))[
                            0] for ch in eeg.reshape(-1, 3)]).reshape(-1, 8) * self.scale_factor_eeg

        if context[&#39;daisy&#39;]:

            # # If offset, the pair index condition must change
            if np.array(self.offset[0]).any():
                eeg_data = np.concatenate([[self.offset[0]], eeg_data], axis=0)
                ids = np.concatenate([[self.offset[1]], ids], axis=0)
                # pair = not pair

            if ids[0] != ids[1]:
                eeg_data = np.delete(eeg_data, 0, axis=0)
                ids = np.delete(ids, 0, axis=0)

            # if not pair dataset, create an offeset
            if eeg_data.shape[0] % 2:
                self.offset = eeg_data[-1], ids[-1]
                eeg_data = np.delete(eeg_data, -1, axis=0)
                ids = np.delete(ids, -1, axis=0)
            else:
                self.offset = None, None

            return eeg_data.reshape(-1, 16)

        return eeg_data</div>

    # ----------------------------------------------------------------------
<div class="viewcode-block" id="BinaryToEEG.deserialize_eeg_serial"><a class="viewcode-back" href="../../openbci_stream.daemons.stream_eeg.html#openbci_stream.daemons.stream_eeg.BinaryToEEG.deserialize_eeg_serial">[docs]</a>    def deserialize_eeg_serial(self, eeg: np.ndarray, ids: np.ndarray, context: Dict[str, Any]) -&gt; np.ndarray:
        &quot;&quot;&quot;From signed 24-bits integer to signed 32-bits integer by channels.

        The `Cyton data format &lt;https://docs.openbci.com/docs/02Cyton/CytonDataFormat&gt;`_
        says that only can send packages of 33 bits, over serial (RFduino) this
        limit is absolute, when a Daisy board is attached these same amount of
        packages will be sent, in this case, the data must be distributed and
        interpolated in order to complete the sample rate.

        Parameters
        ----------
        eeg
            Numpy array in signed 24-bits integer (`8, LENGTH`)
        ids
            List of IDs for eeg data.
        context
            Information from the acquisition side useful for deserializing and
            that will be packaged back in the stream.

        Returns
        -------
        eeg_data
            EEG data in microvolts, signed 32-bits integer, (`CHANNELS, LENGTH`),
            if there is a Daisy board `CHANNELS` is 16, otherwise is 8.
        &quot;&quot;&quot;

        eeg_data = np.array([[rawutil.unpack(&#39;&gt;u&#39;, bytes(ch))[0]
                              for ch in row.reshape(-1, 3).tolist()] for row in eeg])
        eeg_data = eeg_data * self.scale_factor_eeg

        if context[&#39;daisy&#39;]:

            even = not ids[0] % 2

            # If offset, the even index condition must change
            if np.array(self.offset[0]).any():
                eeg_data = np.concatenate([[self.offset[0]], eeg_data], axis=0)
                ids = np.concatenate([[self.offset[1]], ids], axis=0)
                even = not even

            # if not even dataset, create an offset
            if eeg_data.shape[0] % 2:
                self.offset = eeg_data[-1], ids[-1]
                eeg_data = np.delete(eeg_data, -1, axis=0)
                ids = np.delete(ids, -1, axis=0)

            # Data can start with a even or odd id
            if even:
                board = eeg_data[::2]
                daisy = eeg_data[1::2]
            else:
                daisy = eeg_data[::2]
                board = eeg_data[1::2]

            board = np.array([np.interp(np.arange(0, p.shape[0], 0.5), np.arange(
                p.shape[0]), p) for p in board.T]).T
            daisy = np.array([np.interp(np.arange(0, p.shape[0], 0.5), np.arange(
                p.shape[0]), p) for p in daisy.T]).T

            eeg = np.concatenate([np.stack(board), np.stack(daisy)], axis=1)

        else:
            eeg = eeg_data

        return eeg</div>

    # ----------------------------------------------------------------------
<div class="viewcode-block" id="BinaryToEEG.deserialize_aux"><a class="viewcode-back" href="../../openbci_stream.daemons.stream_eeg.html#openbci_stream.daemons.stream_eeg.BinaryToEEG.deserialize_aux">[docs]</a>    @classmethod
    def deserialize_aux(cls, stop_byte: int, aux: int, context: Dict[str, Any]) -&gt; np.ndarray:
        &quot;&quot;&quot;Determine the content of `AUX` bytes and format it.

        Auxialiar data could contain different kind of information: accelometer,
        user defined, time stamped and digital or analog inputs.
        The context of `AUX` bytes are determined by the stop byte.

        If `stop_byte` is `0xc0` the `AUX` bytes contain `Standard with accel`,
        this data are packaged at different frequency, they will be show up each
        10 or 11 packages, the final list will contain accelometer value in `G`
        units for axis `X`, `Y` and `Z` respectively and `None` when are not
        availables.

        If `stop_byte` is `0xc1` the `AUX` bytes contain `Standard with raw aux`,
        there are 3 types of raw data: `digital` in wich case the final list
        will contain the values for `D11`, `D12`, `D13`, `D17`, `D18`; `analog`
        with the values for `A7` (`D13`), `A6` (`D12`), `A5` (`D11`); `markers`
        data contain the the marker sended with `send_marker()` method.

        Parameters
        ----------
        stop_byte
             0xCX where X is 0-F in hex.
        aux
            6 bytes of data defined and parsed based on the `Footer` bytes.
        context
            Information from the acquisition side useful for deserializing and
            that will be packaged back in the stream.

        Returns
        -------
        list
            Correct data formated.

        &quot;&quot;&quot;

        # Standard with accel
        if stop_byte == 0xc0:
            return 0.002 * \
                np.array([struct.unpack(&#39;&gt;hhh&#39;, a.astype(&#39;i1&#39;).tobytes())
                          for a in aux]) / 16

        # Standard with raw aux
        elif stop_byte == 0xc1:

            if context[&#39;boardmode&#39;] == &#39;analog&#39;:
                # A7, A6, A5
                # D13, D12, D11
                return aux[:, 1::2]

            elif context[&#39;boardmode&#39;] == &#39;digital&#39;:
                # D11, D12, D13, D17, D18
                return np.delete(aux, 4, axis=1)

            elif context[&#39;boardmode&#39;] == &#39;marker&#39;:
                # Some time for some reason, marker not always send back from
                # OpenBCI, so this module implement a strategy to send a burst of
                # markers but read back only one.
                a = aux[:, 1]
                a[a &gt; ord(&#39;Z&#39;)] = 0
                a[a &lt; ord(&#39;A&#39;)] = 0
                return a

        # User defined
        elif stop_byte == 0xc2:
            pass

        # Time stamped set with accel
        elif stop_byte == 0xc3:
            pass

        # Time stamped with accel
        elif stop_byte == 0xc4:
            pass

        # Time stamped set with raw auxcalculate_sample_rate
        elif stop_byte == 0xc5:
            pass

        # Time stamped with raw aux
        elif stop_byte == 0xc6:
            pass

        return np.zeros(cls.LAST_AUX_SHAPE)</div>

    # ----------------------------------------------------------------------
<div class="viewcode-block" id="BinaryToEEG.stream"><a class="viewcode-back" href="../../openbci_stream.daemons.stream_eeg.html#openbci_stream.daemons.stream_eeg.BinaryToEEG.stream">[docs]</a>    def stream(self, data, context):
        &quot;&quot;&quot;Kafka produser.

        Stream data to network.

        Parameters
        ----------
        data : list
            The EEG data format.
        samples : int
            The number of samples in this package.

        &quot;&quot;&quot;

        data_ = {&#39;context&#39;: context,
                 &#39;data&#39;: data,
                 }

        self.producer_eeg.send(&#39;eeg&#39;, data_)

        if DEBUG:
            logging.info(f&quot;streamed {samples} samples&quot;)</div></div>


if __name__ == &#39;__main__&#39;:
    tranformer = BinaryToEEG()
    tranformer.consume()
</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../../index.html">
              <img class="logo" src="../../../_static/logo.svg" alt="Logo"/>
            </a></p>
<h3><a href="../../../index.html">Table of Contents</a></h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../notebooks/00-installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../notebooks/01-hardware_configurations.html">Hardware configurations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../notebooks/02-kafka_configuration.html">Kafka configuration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../notebooks/03-data_acquisition.html">Data Acquisition</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../notebooks/04-board_modes.html">Board modes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../notebooks/05-stream_markers.html">Stream markers with Kafka</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../notebooks/06-command_line_interface.html">Command line interface</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../notebooks/07-data_storage_handler.html">Data storage handler</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../notebooks/A1-raw_cleaning.html">Appendix 1 - Raw data processing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../notebooks/A2-electrodes_impedance.html">Appendix 2 - Measuring Electrode Impedance</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../notebooks/A3-server-based_acquisition.html">Appendix 3 - Raspberry PI as server acquisition</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../notebooks/A4-latencies.html">Appendix 4 - System latencies</a></li>
</ul>

<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2019-2021, Yeison Cardona.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 3.5.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
    </div>

    

    
  </body>
</html>